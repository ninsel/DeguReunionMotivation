function rdb = AllReunionDatabase_1()
%ReunionDB = AllReunionDatabase()
%
% puts all of the reunion data into a single database
%
% dependencies: 
%   - EditDist.m
%   - Reun_DB_startimes
%
% the following excel spreadsheets should be available in the local
% directory:
%
% Original time & stress design:
%     Behavioral:
%       - full_behaviour_9pairs_reunion_updated.xlsx
%     Vocalizations:
%       - vocals_reunion_dataonly1.xlsx
% New "cage of four" design:
%     Behavioral:
%       - cageof4_behaviour_8p.xlsx
%     Vocalizations:
%       - vocalizations_new_reunion_experiment_8pairs.xlsx
% Stranger design:
%     Behavioral:
%       - Strangers_behaviour.xlsx
%     Vocalizations:
%        - strangervocalizations.xls
% Oxytocin design:
%      Behavioral:
%       - behaviour_ota_7pairs_leftright.xlsx
%     Vocalizations:
%       - vocals_ota_7pairs_leftright.xlsx
%
% Each element of the ReunionDB struct is a session. 
%  Fields are as follows:
%    First, basic degu info:
%       - paircode (unique across studies, unless the same pair is used)
%       - experiment ('org', 'cof', 'str', 'ota')
%       - degunumbers (2 element vector)
%       - condition (6 element vector: [codenumber time shock cof familiar drug]) 
%                       time: 1/60, .75, 24; 
%                       shock: 0, 1, -1, 1i; 
%                       cof: 0 if full separation, 1 if split cage; 
%                       familiar: 1 if familiar, 0 if stranger; 
%                       drug: -.5i (half left acsf), .5i (half right acsf), 
%                       -i, (full left acsf), i (full right acsf), -.5
%                       (half left) .5 (half right),  -1 (full left), 1
%                       (full right)
%       - age
%       - sessionstartends
%
%    Here, the raw data:
%       - be_start_end (200 x 2 vector of times, start vs. end)
%       - be_ident (200 x 1 vector of behavior identities)
%       - be_who (200 x 2 vector of which degu (0 1, 1 0, 1 1) engaged in
%       action
%       - sl_start_end (200 x 2 vector)
%       - sl_ident (200 length cell array of syllable identities)
%    
%    And finally, some processed data    
%       - be_time
%       - be_num
%       - be_meddur
%       - be_latency
%       - sl_time
%       - sl_rate
%       - sl_rate_voc
%       - sl_voc_latency
%       - sl_be
%
% nei 6/17
%


%FIRST: GETTING ALL OF THE INFORMATION FOR EACH PAIR AND SESSION

%We will go in order in collecting data from each study. The study name
%will be a field in the database. 

%ORIGINAL TIME X STRESS DATASET
excel_files = { 'org' 'full_behaviour_9pairs_reunion_updated.xlsx' 'vocals_reunion_dataonly1.xlsx'; ...
    'cof' 'cageof4_behaviour_8p.xlsx' 'vocalizations_new_reunion_experiment_8pairs.xlsx'; ...
    'str' 'Strangers_behaviour.xlsx' 'strangervocalization.xls'; ...
    'ota' 'behaviour_ota_7pairs_leftright.xlsx' 'vocals_ota_7pairs_leftright.xlsx'; ... 
    'otb' 'OTB_behaviour.xls' 'OTB_vocalizations.xls'};   

org_condcodemap = containers.Map({'A' 'B' 'C' 'D' 'E' 'F'}, {1 2 3 4 5 6});
ota_condcodemap = containers.Map({'A' 'B' 'C' 'D' 'E' 'F'}, {7 8 9 10 11 12});
otb_condcodemap = containers.Map({'A' 'B' 'C' 'D' 'E' 'F'}, {7 12 9 11 8 10});

        
 	% condcodes is an arbitrary code to define the conditions. The isolation
        % time is the second column, and the valence of the exposure during
        % isolation is the third columns
condcodes = [...
    1 1/60 0 0 1 0;...
    2 .75 0 0 1 0;...
    3 24 0 0 1 0;...
    4 .75 1 0 1 0;...
    5 .75 -1 0 1 0;...
    6 .75 1i 0 1 0;...
    149 24 0 1 1 0;...
    136 1/60 0 0 1 0; ...
    146 24 0 0 1 0; ...
    137 24 0 1 1 0; ...
    147 1/60 0 0 1 0; ...
    141 24 0 0 1 0; ...
    130 24 0 1 1 0; ...
    135 1/60 0 0 1 0; ...
    132 24 0 0 1 0; ...
    133 24 0 1 1 0; ...
    131 1/60 0 0 1 0; ...
    134 24 0 0 1 0; ...
    94 24 0 1 1 0; ...
    105 1/60 0 0 1 0; ...
    97 24 0 0 1 0; ...
    104 24 0 1 1 0; ...
    96 1/60 0 0 1 0; ...
    98 24 0 0 1 0; ...
    100 24 0 1 1 0; ...
    95 1/60 0 0 1 0; ...
    99 24 0 0 1 0; ...
    101 24 0 1 1 0; ...
    102 1/60 0 0 1 0; ...
    103 24 0 0 1 0;...
    7 24 0 0 1 -.5i;...
    8 24 0 0 1 -.5;...
    9 24 0 0 1 .5i;...
    10 24 0 0 1 .5;...
    11 24 0 0 1 1;...
    12 24 0 0 1 -1;...
    140 24 0 0 0 0; ...
    142 24 0 0 0 0; ...
    144 24 0 0 0 0; ...
    139 24 0 0 0 0; ...
    145 24 0 0 0 0; ...
    148 24 0 0 0 0; ...
    143 24 0 0 0 0; ...
    138 24 0 0 0 0];

        %paicodes are arbitrary codes used to identify specific pairs, the second
        %column is degu 1 inventory code, column 3 = degu 2 inventory code

paircodes = [1 1203 1007 datenum(2014, 10, 14) datenum(2015, 09, 28) datenum(2016, 5, 01);...
            2 2204 2204 datenum(2015,08,19) datenum(2015,08,19) datenum(2016, 5, 01);...
            3 2601 2601 datenum(2015,10,13) datenum(2015,10,13) datenum(2016, 5, 01);...
            4 100605 100606 datenum(2015,05,10) datenum(2015, 05, 10) datenum(2016, 5, 01);...
            5 240105 240106 datenum(2015,10,21) datenum(2015,10,21) datenum(2016, 5, 01);...
            6 260104 100607 datenum(2015,10,13) datenum(2015,05,10) datenum(2016, 5, 01);...
            7 280206 210304 datenum(2015,08,30) datenum(2015,07,20) datenum(2016, 5, 01);...
            8 280204 280205 datenum(2015,08,30) datenum(2015,08,30) datenum(2016, 5, 01);...
            9 210305 210306 datenum(2015,07,20) datenum(2015,7,20) datenum(2016, 5, 01);...
            149 280301 280303 datenum(2016,02,09) datenum(2016,02,09) datenum(2016,08,09);...
            136 280301 280303 datenum(2016,02,09) datenum(2016,02,09) datenum(2016,08,09); ...
            146 280301 280303 datenum(2016,02,09) datenum(2016,02,09) datenum(2016,08,09); ...
            137 280302 280304 datenum(2016,02,09) datenum(2016,02,09) datenum(2016,08,09); ...
            147 280302 280304 datenum(2016,02,09) datenum(2016,02,09) datenum(2016,08,09); ...
            141 280302 280304 datenum(2016,02,09) datenum(2016,02,09) datenum(2016,08,09); ...
            130 210401 210403 datenum(2015,10,14) datenum(2015,10,14) datenum(2016,08,09); ...
            135 210401 210403 datenum(2015,10,14) datenum(2015,10,14) datenum(2016,08,09); ...
            132 210401 210403 datenum(2015,10,14) datenum(2015,10,14) datenum(2016,08,09); ...
            133 210402 210404 datenum(2015,10,14) datenum(2015,10,14) datenum(2016,08,09); ...
            131 210402 210404 datenum(2015,10,14) datenum(2015,10,14) datenum(2016,08,09); ...
            134 210402 210404 datenum(2015,10,14) datenum(2015,10,14) datenum(2016,08,09); ...
            94  230201 230203 datenum(2015,10,31) datenum(2015,10,31) datenum(2016,08,09); ...
            105 230201 230203 datenum(2015,10,31) datenum(2015,10,31) datenum(2016,08,09); ...
            97  230201 230203 datenum(2015,10,31) datenum(2015,10,31) datenum(2016,08,09); ...
            104 230202 230204 datenum(2015,10,31) datenum(2015,10,31) datenum(2016,08,09); ...
            96  230202 230204 datenum(2015,10,31) datenum(2015,10,31) datenum(2016,08,09); ...
            98  230202 230204 datenum(2015,10,31) datenum(2015,10,31) datenum(2016,08,09); ...
            100 240301 240303 datenum(2016,02,27) datenum(2016,02,27) datenum(2016,08,09); ...
            95  240301 240303 datenum(2016,02,27) datenum(2016,02,27) datenum(2016,08,09); ...
            99  240301 240303 datenum(2016,02,27) datenum(2016,02,27) datenum(2016,08,09); ...
            101 240302 240304 datenum(2016,02,27) datenum(2016,02,27) datenum(2016,08,09); ...
            102 240302 240304 datenum(2016,02,27) datenum(2016,02,27) datenum(2016,08,09); ...
            103 240302 240304 datenum(2016,02,27) datenum(2016,02,27) datenum(2016,08,09); ...
            140 220301 280302 datenum(2015,05,28) datenum(2016,02,09) datenum(2016,08,09); ...
            142 120206 280301 datenum(2014,03,16) datenum(2016,02,09) datenum(2016,08,09); ...
            144 230204 280204 datenum(2015,10,31) datenum(2015,08,30) datenum(2016,08,09); ...
            139 230205 280203 datenum(2015,10,31) datenum(2015,08,30) datenum(2016,08,09); ...
            145 240302 280302 datenum(2016,02,27) datenum(2016,02,09) datenum(2016,08,09); ...
            148 280301 240301 datenum(2016,02,09) datenum(2016,02,27) datenum(2016,08,09); ...
            143 444401 230208 nan datenum(2015,10,31) datenum(2016,08,09); ...
            138 444402 230207 nan datenum(2015,10,31) datenum(2016,08,09);...
            16 260102 260103 datenum(2015,10,13) datenum(2015,10,13) datenum(2016, 5, 01); ...
            12 240105 240106 datenum(2015,10,21) datenum(2015,10,21) datenum(2016, 5, 01); ...
            11 100607 220403 datenum(2015,05,10) datenum(2015,08,19) datenum(2016,6,17); ...
            10 100605 100606 datenum(2015,05,10) datenum(2015,05,10) datenum(2016,6,17); ...
            13 210304 280206 datenum(2015,07,20) datenum(2015,08,30) datenum(2016,7,1) ; ...
            14 280204 280205 datenum(2015,08,30) datenum(2015,08,30) datenum(2016,7,1); ...
            15 210305 210306 datenum(2015,07,20) datenum(2015,07,20) datenum(2017, 7, 1);...
            17 230204 230205 datenum(2015,10,31) datenum(2015,10,31) datenum(2016, 10,1);...
            18 230207 230208 datenum(2015,10,31) datenum(2015,10,31) datenum(2016, 10,1);...
            19 280304 280305 datenum(2016,02,09) datenum(2016,02,09) datenum(2016, 10,1);...
            ]; 

posnegbehave = containers.Map({...
    'Antagonistic (pushing, biting, mounting)'...
    'Bathing in bedding'...
    'END'...
    'Freezing'...
    'Ignoring face to face'...
    'Inactive'...
    'Laying on top of each other but inactive'...
    'Lifting arm'...
    'Motion to groom ahead'...
    'Motion to groom ahead '...
    'Reunion'...
    'antagonistic (pushing, biting, mounting)'...
    'bathing and bedding'...
    'body grooming (ears,  neck and body)'...
    'body grooming (ears, neck, body)'...
    'butt sniff/groom'...
    'end'...
    'end point'...
    'face to face'...
    'face to face '...
    'laying on top of each other but inactive'...
    'reunion'...
    'sleeping'},...
    {-1 0 0 0 0 0 4 0 0 0 0 -1 0 1 1 2 0 0 3 3 4 0 0});

voctypes = {...
    'whistle'...
    'pain'...
    'bark'...
    'chaff'...
    'chirp'...   
    'chitter'...
    'groan'...
    'groan/unknown'...
    'grunt'...
    'high freq chirp'...
    'high freq loud whistle'...
    'high freq squeal'...
    'high freq warble'...
    'long whine'...
    'loud whine'...
    'loud whistle'...  
    'low freq'...
    'low freq whistle'...
    'low warble'...
    'low whine'...
    'low whistle'...          
    'pain squeak'   ... 
    'pip'...
    'squeak'...
    'squeal'...
    'squeal pain'...
    'tweet'    ...
    'unknown'    ...
    'warble'...
    'wheep'...
    'whine'...
    'whine/warble'...
    };

% voctypes = {...
%  1   'whistle';...
%  2   'pain';...
%  3   'bark';...
%  4   'chaff';...
%  5   'chirp';...   
%  6   'chitter';...
%  7   'groan';...
%  8   'groan/unknown';...
%  9   'grunt';...
%  10   'high freq chirp';...
%  11   'high freq loud whistle';...
%  12   'high freq squeal';...
%  13   'high freq warble';...
%  14   'long whine';...
%  15   'loud whine';...
%  16   'loud whistle';...  
%  17   'low freq';...
%  18   'low freq whistle';...
%  19   'low warble';...
%  20   'low whine';...
%  21   'low whistle';...          
%  22   'pain squeak' ;  ... 
%  23   'pip';...
%  24   'squeak';...
%  25   'squeal';...
%  26   'squeal pain';...
%  27   'tweet';    ...
%  28   'unknown';    ...
%  29   'warble';...
%  30   'wheep';...
%  31   'whine';...
%  32   'whine/warble';...
%     };


%
%
%SECOND: READING THE EXCEL FILES, AND FILLING-IN THE GAPS
%
%

rdb = struct;
kk = 0; %this will be the index to our ever-expanding structure

for ii = 1:size(excel_files,1)
    [~, ~, behav_raw] = xlsread(excel_files{ii,2});
    [~, ~, reun_raw] = xlsread(excel_files{ii,3});
    
    %the next function provides data specific to each study/data
    %spreadsheet
	p = fill_params(excel_files{ii,1});
    
    %correct typos in the type columns
    for i = 1:size(behav_raw,ii)
        if ~ischar(behav_raw{ii, p.behav_type});
            behav_raw{ii,behav_type} = '';
        end
    end
    
%correct typos and convert the syllables to a syllable code
% This takes time!  Also, it requires the function "EditDist"
    sylltypes = zeros(size(reun_raw,1),1);
    for i = 1:size(reun_raw,1)
        if ~ischar(reun_raw{i, p.syll_voctype});
            reun_raw{i,p.syll_voctype} = '';
            sylltypes(i) = 0;
        else
            g = [];
            for j = 1:length(voctypes)
                g(j) = EditDist(voctypes{j}, reun_raw{i, p.syll_voctype});
            end
            [~, sylltypes(i)] = min(g);
        end
     
    end
    
 %compute starttimes from the syllable data
    starttimes = Reun_DB_starttimes2(reun_raw(:,p.syll_filename));
    ind3p = find([reun_raw{:,p.syll_parcode}] < 4);
  %  starttimes(ind3p) = starttimes(ind3p) + .5; %we add this because the first three pairs had temporally imprecise start times (????)

       
 %find the session start end end times from the behavior spreadsheet
    b_sessstarts_ind = find(strcmpi('reunion', behav_raw(:,p.behav_type)));
    b_ss = [behav_raw{b_sessstarts_ind, p.behav_timesec}];
    b_ss_p = [behav_raw{b_sessstarts_ind, p.behav_paircode}];
    b_ss_c = nan(length(b_sessstarts_ind),1);
    if strcmp(excel_files{ii,1}, 'org')
        for i = 1:length(b_sessstarts_ind)
            b_ss_c(i) = org_condcodemap(behav_raw{b_sessstarts_ind(i), p.behav_condcode});
        end
    elseif strcmp(excel_files{ii,1}, 'ota')
        for i = 1:length(b_sessstarts_ind)
            b_ss_c(i) = ota_condcodemap(behav_raw{b_sessstarts_ind(i), p.behav_condcode});
        end
    else
        b_ss_c = [behav_raw{b_sessstarts_ind, p.behav_condcode}]';       
    end
       
    b_sessionstarts = [b_ss' b_ss_p' b_ss_c];
    
    b_sessends_ind = [b_sessstarts_ind(2:end) - 1 ;  size(behav_raw,1)];%  find(strcmpi('end', behav_raw(:, p.behav_type)));
    b_se = [behav_raw{b_sessends_ind, p.behav_timesec}]';
    b_se_p = [behav_raw{b_sessends_ind, p.behav_paircode}];
    b_se_c = nan(length(b_sessstarts_ind),1);
    if strcmp(excel_files{ii,1}, 'org')
        for i = 1:length(b_sessstarts_ind)
            b_se_c(i) = org_condcodemap(behav_raw{b_sessends_ind(i), p.behav_condcode});
        end
    elseif strcmp(excel_files{ii,1}, 'ota')
        for i = 1:length(b_sessstarts_ind)
            b_se_c(i) = ota_condcodemap(behav_raw{b_sessends_ind(i), p.behav_condcode});
        end
    else
        b_se_c = [behav_raw{b_sessstarts_ind, p.behav_condcode}]';       
    end
    b_sessionends = [b_se b_se_p' b_se_c];
    
	bstarts = find(strcmp('START', behav_raw(:,p.behav_startend)));
 	bends = find(strcmp('STOP', behav_raw(:,p.behav_startend)));
    
    be_start_end = nan(300,2);
    be_identcode = nan(300,1);
    be_who = zeros(300,2);
 
 %Loop through the behavior events, adding them to the start_end matrix and
 %identity cell array
    for jj = 1:length(b_sessionstarts)
        kk = kk + 1;
        rdb.paircode(kk) = b_sessionstarts(jj,2);
        rdb.experiment{kk} = excel_files{ii,1};
        pdegunums = find(paircodes(:,1) == b_sessionstarts(jj,2));
        if length(pdegunums) ~= 1 
            error('pairnumbers should be unique.');
        end
        rdb.degunumbers(kk,1:2) = paircodes(pdegunums,2:3);
        rdb.age(kk) = paircodes(pdegunums,6) - min(paircodes(pdegunums,4:5));
        pcc = nan(length(b_sessstarts_ind),1);
        if strcmp(excel_files{ii,1}, 'org')
            pcc = org_condcodemap(behav_raw{b_sessstarts_ind(jj), p.behav_condcode});
            rdb.condition(kk,:) = condcodes(find(condcodes(:,1) == pcc), :);
        elseif strcmp(excel_files{ii,1}, 'ota') 
            pcc = ota_condcodemap(behav_raw{b_sessstarts_ind(jj), p.behav_condcode});
           	rdb.condition(kk,:) = condcodes(find(condcodes(:,1) == pcc), :);
     	elseif strcmp(excel_files{ii,1}, 'otb') 
            pcc = otb_condcodemap(behav_raw{b_sessstarts_ind(jj), p.behav_condcode});
           	rdb.condition(kk,:) = condcodes(find(condcodes(:,1) == pcc), :);
        else
            rdb.condition(kk,:) = condcodes(find(condcodes(:,1) == behav_raw{b_sessstarts_ind(jj), p.behav_condcode}),:);
        end
        rdb.sessionstart_end(kk,:) = [b_sessionstarts(jj) b_sessionends(jj)];
        bstarts_sess = intersect(bstarts, b_sessstarts_ind(jj):b_sessends_ind(jj));
        bends_sess = intersect(bends, b_sessstarts_ind(jj):b_sessends_ind(jj));
        
        rdb.be_start_end(:,:,kk) = be_start_end;
        rdb.be_identcode(:,kk) = be_identcode;
        %need to make sure we are matching the "ends" to the correct
        %"starts"
        if isempty(bstarts_sess)
            dbstop = 1;
        end
        for i = 1:length(bstarts_sess)
            rdb.be_start_end(i,1,kk) = behav_raw{bstarts_sess(i), p.behav_timesec};
            rdb.be_ident{i,kk} = behav_raw{bstarts_sess(i), p.behav_type};
           if isKey(posnegbehave, behav_raw{bstarts_sess(i),p.behav_type});
               rdb.be_identcode(i,kk) = posnegbehave(behav_raw{bstarts_sess(i),p.behav_type});
           else
               rdb.be_identcode(i,kk) = nan;
           end
           if ~isnan(behav_raw{bstarts_sess(i), p.behav_ident})
               if strcmpi(behav_raw{bstarts_sess(i), p.behav_ident}(1:3), 'unp') | strcmpi(behav_raw{bstarts_sess(i), p.behav_ident}(1:3), 'bot')
                   rdb.be_who(i,1,kk) = 1;
               end
                if strcmpi(behav_raw{bstarts_sess(i), p.behav_ident}(1:3), 'pai') | strcmpi(behav_raw{bstarts_sess(i), p.behav_ident}(1:3), 'bot')
                   rdb.be_who(i,2,kk) = 1;
                end           
           end
            indsamebehav = find(strcmp(behav_raw{bstarts_sess(i),p.behav_type}, behav_raw(bends_sess,p.behav_type)) & bends_sess > bstarts_sess(i));
            if ~isempty(indsamebehav)
                rdb.be_start_end(i,2,kk) = behav_raw{bends_sess(indsamebehav(1)), p.behav_timesec};
            end
        end

        
    %now the raw data for syllables
    
    %first check if the condition code is a character or number, then
    %identify the relevant rows accordingly
        if ischar(reun_raw{1,p.syll_condcode})        
            allsesssylls = find([reun_raw{:,p.syll_parcode}]' == b_sessionstarts(jj,2)...
                & strcmp(reun_raw(:,p.syll_condcode), behav_raw{b_sessstarts_ind(jj), p.behav_condcode})); 
        else
            allsesssylls = find([reun_raw{:,p.syll_parcode}]' == b_sessionstarts(jj,2)...
                & [reun_raw{:,p.syll_condcode}]' == b_sessionstarts(jj,3)); 
        end
           
    %Now find the start and end times of each of those syllables   
    
        rdb.sl_start_end(:,:,kk) = nan(2100,2);
        rdb.sl_identcode(:,kk) = nan(2100,1);
        if ~isempty(allsesssylls)
         	startpoint = [reun_raw{allsesssylls, p.syll_starttime}]'/1000 + starttimes(allsesssylls);
         	endpoint = [reun_raw{allsesssylls, p.syll_starttime}]'/1000 + [reun_raw{allsesssylls, p.syll_dur}]'/1000 + starttimes(allsesssylls);
            allstartends = [startpoint endpoint];
            
            [allstartends neworder] = sortrows(allstartends);
            rdb.sl_start_end(1:length(startpoint),:,kk) = allstartends;
            rdb.sl_clipstart(1:length(startpoint),:,kk) = [[reun_raw{allsesssylls, p.syll_starttime}]' [[reun_raw{allsesssylls, p.syll_starttime}]' + [reun_raw{allsesssylls, p.syll_dur}]']];
            for i = 1:length(allsesssylls)
             	rdb.sl_vocclip{i,kk} = reun_raw{allsesssylls(neworder(i)), p.syll_filename};
            	rdb.sl_ident{i,kk} = reun_raw{allsesssylls(neworder(i)), p.syll_voctype};
                voccode = find(strcmp(rdb.sl_ident{i,kk}, voctypes));
                if ~isempty(voccode)
                    rdb.sl_identcode(i,kk) = find(strcmp(reun_raw{allsesssylls(neworder(i)), p.syll_voctype}, voctypes));
                end
            end
        end
    end       
% 
%             bemat = nan(length(bstarts), 5);
% 
% 
% for ii = 1:length(bstarts)
%     bemat(ii,1) = behav_raw{bstarts(ii),p.behav_paircode};
%     bemat(ii,2) = behav_raw{bstarts(ii),p.behav_condcode};
%  
%  	if isKey(posnegbehave,  behav_raw{bstarts(ii), behav_type})
%         bemat(ii,3) = posnegbehave(behav_raw{bstarts(ii), behav_type});
%     end
%     bemat(ii,4) = behav_raw{bstarts(ii),behav_timesec};
%     indsamebehav = find(strcmp(behav_raw{bstarts(ii),behav_type}, behav_raw(bends,behav_type)));
%     indsamebehav = indsamebehav(bends(indsamebehav) > bstarts(ii));
%     if ~isempty(indsamebehav)
%         dur = behav_raw{bends(indsamebehav(1)),behav_timesec} - behav_raw{bstarts(ii),behav_timesec};    
%         if dur > 0
%             bemat(ii,5) = dur;
%         end
%     end
% end
%
%    Here, the raw data:
%       - be_start_end (200 x 2 vector of times, start vs. end)
%       - be_ident (200 x 1 vector of behavior identities)
%       - sl_start_end (200 x 2 vector)
%       - sl_ident (200 length cell array of syllable identities)
%    
%    And finally, some processed data    
%       - be_time
%       - be_num
%       - be_meddur
%       - be_latency
%       - sl_time
%       - sl_rate
%       - sl_rate_voc
%       - sl_voc_latency
%       - sl_be
%
    
    
    
end
 
end


function p = fill_params(dataset_ident)
%dataset options are 
% 'orig'
% 'cof'
% 'str'
% 'oxy'
%

switch dataset_ident
    case 'org'
        p.syll_parcode = 2;
        p.syll_condcode = 3;
        p.syll_dur = 4;
        p.syll_starttime = 5;
        p.syll_filename = 25;
        p.syll_voctype = 26;
        
        p.behav_paircode = 1;
        p.behav_condcode = 2;
        p.behav_timesec = 3;
        p.behav_ident = 4; %'painted' and 'unpainted'
        p.behav_type = 5;
        p.behav_startend = 6;
           
    case 'cof'
        p.syll_parcode = 1;
        p.syll_condcode = 1;
        p.syll_dur = 2;
        p.syll_starttime = 3;
        p.syll_filename = 23;
        p.syll_voctype = 24;

        p.behav_paircode = 1;
        p.behav_condcode = 1;
        p.behav_timesec = 2;
        p.behav_ident = 3; %'painted' and 'unpainted'
        p.behav_type = 4;
        p.behav_startend = 5;

    case 'str'
        p.syll_parcode = 1;
        p.syll_condcode = 1;
        p.syll_dur = 2;
        p.syll_starttime = 3;
        p.syll_filename = 23;
        p.syll_voctype = 24;

        p.behav_paircode = 1;
        p.behav_condcode = 1;
        p.behav_timesec = 2;
        p.behav_ident = 3; %'painted' and 'unpainted'
        p.behav_type = 4;
        p.behav_startend = 5;
                
    case 'ota'        
        p.syll_parcode = 2;
        p.syll_condcode = 3;
        p.syll_dur = 4;
        p.syll_starttime = 5;
        p.syll_filename = 25;
        p.syll_voctype = 26;

        p.behav_paircode = 1;
        p.behav_condcode = 2;
        p.behav_timesec = 3;
        p.behav_ident = 4; %'painted' and 'unpainted'
        p.behav_type = 5;
        p.behav_startend = 6;
        
    case 'otb'
    	p.syll_parcode = 1;
        p.syll_condcode = 2;
        p.syll_dur = 3;
        p.syll_starttime = 4;
        p.syll_filename = 24;
        p.syll_voctype = 25;

        p.behav_paircode = 1;
        p.behav_condcode = 2;
        p.behav_timesec = 3;
        p.behav_ident = 4; %'painted' and 'unpainted'
        p.behav_type = 5;
        p.behav_startend = 7;
                
end
end
